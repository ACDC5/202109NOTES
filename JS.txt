js
要多动手写代码
不要完全停留在语法，要对js的思想和她的设计有深刻的理解；
因为所有编程语言的思想和设计都是相通的，但语法不是。

高阶学习: https://www.bilibili.com/video/BV14s411E7qf?p=9&spm_id_from=pageDriver
基础总结深入:
js的判断手段:
	*typeof可以判断：数值/字符串/布尔值/undefined/function
			不能区别:null与Object，Array

	*instanceof:判断对象的具体类型

	* ===: null/undefined
内存分类:栈，堆
每个内存都有地址，
全局和局部变量名(包括函数名也是一种变量)在栈空间；变量值、对象在堆空间

* 内存只有读和写的操作，=左边是写，右边是读；let a = 7;

代码执行过程:代码被读取到内存中，进行编译，最后解析执行

内存:存储数据的空间，
变量:是数据在内存中的标识，通过变量值找到对应的内存，进而操作内存中的数据

赋值时发生的情况: 
var a = xxx,a内存中保存的是什么？
*当xxx是基本类型的数据时，内存保存的就是这个数据本身
*当xxx是对象时，保存的是对象在(堆)内存中的地址值，而不是对象的内容
*当xxx是一个变量，保存的是xxx的内容(要么基本数据，要么是地址值)

同理:变量和变量之间的赋值都是传值，重点是，赋值的是基本类型的值还是对象


关于引用变量赋值:
问题1：
 //将obj1(它本身有自己的内存地址)的内容的内存地址保存到obj2(相当于copy地址值)
 //当两个或多个引用变量指向同一个对象时，操作这些引用变量(地址值)
 都是在操作同一个对象(所以通过一个变量修改对象内部数据，其他变量看到的是修改之后的数据)
 var obj1 = {name:'tom'}
 var obj2 = obj1
 obj1.name='jack'
 console.log(obj2.name) //jack
-----------------------------------------------
问题2：
两个引用变量指向同一个对象，让其中一个变量指向另一个对象，
另一个引用变量依然指向前一个对象。

var a = {age:12}
var b = a
a = {name:'bob',age:13} //a在这里可以说是新建的对象(内存地址变了);第一行的a变量内存地址消失了，但它的值的内存地址还在被b引用，
console.log(b.age,a.name,a.age) //12  bob 13

function fn2(obj) {
    obj = {age: 15};
  }
  fn2(a);
  console.log(a.age); // 13 为什么不是15，
  在fn2函数体执行前，obj被实参a赋值后其引用的指向是对象a的内存地址；
  执行函数体后，此时的obj不再指向a内存地址，指向的是一个新的对象地址obj，所以输出的a.age和obj无关
------------------------------------------------------------------------

 问题3:在js调用函数传递变量参数时，是值传递还是引用传递?
 理解一:都是值传递，区别在于，如果传递的是基本类型数据，那么传递的就是值本身；如果传递的是对象，那实际传递的就是地址值.
 		需要注意,形参和实参他们时两个不相干的变量，尽管有时它们被写成同名，所以方法执行中形式参数值的改变不影响实际参数的值;

 		如果传递的是对象(数组也是对象)，则传递的是地址值(就是所谓的引用传递，本质还是值传递)，
 		实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，
 		这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数。

 var a = 3;
  function fn(a) { //形参a是局部变量
    a = a + 1; 
  }
  fn(a); // 实参a是全局变量。将实参的值(而非实参变量)赋值给形参后，形参a实际是一个新的变量(只在fn函数内可用)，不要因为同名把它们混在一起
  console.log(a); //输出3 所以这里的输出值，完全没有受到fn函数的影响


  function fn2(obj){ //形参接收实参传过来的值(即对象的地址值)，它们指向了同一个对象，所以操作形参将会实参也改变
  	console.log(obj.name)
  }

  var obj = {name:'tom'}
  fn2(obj) //输出tom


-----------------------------------------------------------------

问题4：js引擎如如何管理内存
	a.内存的生命周期：
		*分配小内存空间，得到它的使用权；
		*存储数据，可以反复进行操作；
		*释放小内存空间

	b.释放内存
		局部变量:函数执行完自动释放；
		对象: 成为垃圾对象(没有引用指向的对象--将对象的引用重新赋值为null，对象就会变为垃圾对象)--->垃圾回收器回收;
		全局变量:关闭浏览器时全局变量才会被释放;

	var a = 3
	var obj = {} //这两行代码有三个内存空间，分别时a、obj、和对象{}；
	浏览器执行完这两行代码后，它们的内存空间不会被释放(在浏览器控
	制台输入上面两个变量时它们的值会被打印)，因为它们是全局变量
	

	function fn5(){
		var b = {}
	}

	fn() // 局部变量b在函数被调用的时候才被存入内存(局部变量此时被创建);
		//	当函数执行完后，函数内的所有局部变量占用的空间都会立即释放
			b是自动释放的，b所指向的对象是在后面某个时刻由垃圾回收器回收的

---------------------------------------------------
函数:
执行函数的方式：
	testFn()--直接调用
	obj.testFn()--通过对象调用
	new testFn()--new调用
	testFn.call/apply(object)--临时让testFn成为object对象的方法进行调用

	*new一个对象背后做了什么？
		1创建一个对象
		2给对象设置__proto__，值为构造函数对象的prototype属性值
			即this.__proto__ = MyFn.prototype
		3执行构造函数体(给对象添加属性、方法)

var myObj = {};

  function test() {
    this.xxx = 'test fn';
  }
  // myObj.test(); // myObj不能调用该函数，他没有test函数
  test.(myObj); // 可以让一个函数成为指定任意对象的方法进行调用
  console.log(myObj.xxx); // test fn


 函数的定义方式:
 	函数声明:直接声明一个函数，使用该方式存在函数提升
 	函数表达式声明:var fnName = function(){...}

-------------------------------------------------------

什么是回调函数(回调函数都是匿名函数):
	1、你定义的；
	2、你没有调用;
	3、但最终被执行了(在某个时刻，或在某个条件下)

常见的回调函数:dom事件回调函数(点击、聚焦等事件)、定时器回调函数、
			  目前不讲:ajax请求回调函数、生命周期回调函数

回调函数补充:
	第3集:https://www.bilibili.com/video/BV1WE411P7e6?p=3

	*两种类型的回调函数
		1、同步回调：
			*立即执行，完全执行完了才结束，不会被放入回调队列中
			*例如,数组遍历相关的回调函数；promise的excutor函数

				const arr = [1,3,5,7]
				arr.forEach(item => {//遍历回调，不会放入队列，一上来就要执行完
					console.log(item)
				})
				console.log('foreach之后')


		2、异步回调：
			*不会立即执行，回放入回调队列中将来执行
			*例如，定时器回调，ajax回调，promise的成功/失败的回调；

				setTimeout(() => {//异步回调函数，会放入队中将来执行
					console.log('timeout回调')
				}, 0);
				console.log('timeout之后')

-------------------------------------------------------

arguments 是一个对应于传递给函数的参数的类数组对象，
arguments对象是所有（非箭头）函数中都可用的局部变量
用法:
	function fn() {
		console.log(arguments)
		console.log(arguments[3])
	}
	fn(1,2,3,4,5)


IIFE()：立即执行函数表达式(匿名函数自调用): 

	(function () { 	//匿名函数自调用
		console.log('...')
	})() 	//此括号表示立即执行

IIFE的作用:
	1、隐藏实现(外部代码无法访问函数内部)；
	2、不污染外部(全局)命名空间，即局部变量不会污染全局变量(即使它们同名)；
	3、用它来编码js模块


;(function () { // 如果这个IIFE上面还有别的代码，需要在该代码后面加分号，或者在IIFE前加分号，否则执行时会将它们看成是一个整体，导致报错
	var a = 1
	function test(){
		console.log(a++)
	}
	window.$ = function() {	//向外暴露一个全局函数
		return {
			test:test
		}
	}
})()

$().test() // 通过向外暴露的全局函数调用test函数；$是一个函数，执行后返回的是一个对象，这个对象里面有个test方法(.的左边是对象; ()的左边的函数)

------------------------------------------------------------------------------------------

1、this是什么:
	
	*js解析器在调用函数时，每次都会向函数内部传递进一个隐含参数，
	 这个隐含参数就是this。this指向的是一个对象，这个对象成为
	 函数执行上下文对象

	 *根据函数的调用方式的不同，this会指向不同的对象

	当全局函数被以函数的方式调用时该函数的this指向是window:
		function a(){...} //全局函数
		a() 以函数的方式调用，this指向window

	*任何函数本质上都是通过某个对象来调用的，如果没有直接指定就默认是window对象

	*所有函数内部都有一个隐含变量this
	*它的值是调用函数的当前对象

2、如何确定函数内部this的值:
	test() // this指向window对象;单独使用，this引用(代表)全局对象
	p.test() // p,谁调用指向谁;
	new test() //this指向新创建的对象实例
	p.test.call(obj) //this指向obj,test方法由指定的对象调用.

	在事件中，this引用(代表)接收事件的的元素
	回调函数中的this指向:document元素或window

	test()//称为函数
	a.test()//称为方法


---------------------------------------------

分号问题:
	*是否加分号是编码风格问题，属于个人选择问题；
	*在下面两种情况下不加分号会有问题:
		1、小括号开头的前一条语句；
		2、中阔号开头的前一天语句；

	*解决办法:在行首加分号；


---------------------------------------------------------------
原型链基础教程:https://www.bilibili.com/video/BV1YW411T7GX?p=66(已看完)
函数高级:
原型和原型链:p16-17需要多看几遍
			js高级:https://www.bilibili.com/video/BV14s411E7qf?p=18&spm_id_from=pageDriver
函数的prototype:

	问题:当存在两个相同的全局变量名时(函数也是全局变量)，后者会覆盖前者(污染了全局作用域的命名空间)，而且定义在全局作用中也很不安全；
	解决:可以将全局变量定义到相应的原型对象中。

	原型(prototype):
		
		我们所创建的每一个函数(包括构造器)，解析器都会向函数中添加
		一个属性prototype，这个属性对应着一个对象，这个对象既是所谓的原型对象(__proto__)；

		所有函数都有两个属性:一个显式原型prototype，一个隐式原型__proto__

		一个对象的所有引用都可访问到该对象的原型对象；
		原型对象也是对象，所以原型对象也有原型;

		如果函数作为普通函数调用prototype没有任何作用，
		当函数以构造函数调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性


	作用：
		1、原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到对象中去；

		2、原型链方便查找对象的属性(方法)，不是用来查找变量的(查找变量看作用域链);

		以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，
		这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个实例对象都具有这些属性和方法了

		function MyCookie() {

		} //这种写法等同于 var MyCookie = new Function()；Function是所有函数的爹，Function和其他函数不同的是，
			//它的__proto__指向它自己；Function.prototype是个对象，所有它的__proto__指向的是Object(这段描述不知是否准确)

		function People() {

		}

		var mc = new MyCookie();
		var mc2 = new MyCookie();

		console.log(mc.prototype == mc2.prototype) //true mc和mc2这两个实例指向同一个原型对象

		var p = new People();
		console.log(p.prototype == mc.prototype) //false

		mc2.a = '我是mc2实例的属性' //只有mc2这个对象实例可以使用a属性；
		mc2.test = function() {...} //只有mc2这个对象实例可以使用该函数

		MyCookie.prototype.a = 123; //向MyCookie的原型中添加属性a；所有Mycookie的实例都能访问到这个属性

		Mycookie.prototype.sayHello = function(){...}// 向MyCookie的原型中添加函数sayHello；所有Mycookie的实例都能访问到这个函数

		Mycookie.prototype.toString = function() {...}//修改MyCookie原型中的toString方法,所有Mycookie的实例被...log输出时不再
		打印为默认的"[object Object]",而是打印成重新定义toString函数后的实现

		console.log('属性名' in mc) //使用 in检查对象中是否有某个属性时，如果对象中没有但原型中有，也会返回true

		console.log(mc.hasOwnProperty('属性名')) // 使用 hasOwnProperty()，只检查自身象中是否有某个属性，如果有返回true，该方法不会去原型中对象中检查


	当我们访问对象的一个属性或方法时，它会现在对象自身中寻找，如果有则直接使用，
	如果没有则会去原型对象中寻找，如果找到则直接使用,如果在原型对象中没有找到，就会去原型对象的原型中找，
	直到找到	Object对象的原型(Object对象的原型的值是null)，如果在Object对象的原型中没
	有找到想要的属性或方法，则返回undefined，Object的__proto__中唯一的值是null；
	简单理解:在自身找，如果没有-->在父原型找，没找到-->祖...
	代码(mc.__proto__.__proto__.__proto__.fun),这就是所谓的原型链。有点像java的父类子类概念；

	原型链别名:隐式原型链


	Function.prototype(是Object的实例)本身是一个函数对象(用instanceof Object时返回true)

	myFun().call：因为点的左边是对象，所以myFun()在这里是一个函数对象，
	myFun()在调用函数原型(prototype)上的call属性,只有函数才有或函数对象才有protorype属性


	所有函数的原型对象默认都是Object实例，Object()除外

	函数的prototype属性(显式原型):在定义函数时自动添加的，默认值是一个空的Object实例对象；
		
	对象的__proto__属性(隐式原型):创建对象时自动添加的，默认值为构造函数的prototype属性值，
	程序员能直接操作显示原型，但最好不要直接操作隐式原型(ES6之前)；

	实例对象的隐式原型(属性的值) 等于 构造函数的显式原型(属性的值)


	function Fn() {
	    this.test1 = function() {
	        console.log('test1')
	    }
	}
	console.log(Fn.prototype)

	Fn.prototype.test2 = function() {
	    console.log('test2')
	}

	var fn = new Fn()
	fn.test1()
	fn.test2()
	console.log(fn.toString())
	console.log(fn.test3) //实例自身没有找到该方法，去原型(链)找，最终没找到返回undefined
	// fn.test3() //右侧加了括号，表示将test3当作一个函数同时去执行了该函数，而实例对象及其原型链中不存在该方法，会直接丢出报错信息

	console.log(Fn.prototype instanceof Object) //true 说明Fn.prototype是一个Object的实例(
												//所有函数都是Function的孩子；所有函数都是Function的实例，包括Function本身，没有例外)

	console.log(Object.prototype instanceof Object) //false  函数的prototype属性(显式原型):在定义
													//函数时自动添加的，默认值是一个空Object对象(这个空对象不是Object的实例)；

	console.log(Function.prototype instanceof Object) //true 说明Function.prototype是一个Object的实例


	console.log(Function.__proto__ === Function.prototype) //true 所有函数都是Function的实例,没有例外，包括Function本身(Function是通过new自己产生的实例)


原型链的属性问题:

	1、读取对象属性时会先从自身对象找，自身有则使用，无则去原型链查找属性
	2、设置对象的属性值时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值
	3、方法一般定义在原型中，属性一般通过构造函数定义在对象本身上
	
	function Fn() {
           
    }
    
    Fn.prototype.a = 'xxx'
    
    let fn1 = new Fn()
    console.log(fn1.a)

    let fn2 = new Fn()
    fn2.a = 'yyy'

    console.log(fn1.a,fn2.a) //xxx yyy



    function Person(name,age) {
        this.name = name
        this.age = age
    }
    Person.prototype.setName = function(name) {
        this.name = name
    } // 将方法设置在原型链上

    let p1 = new Person('Tom',12)
    p1.setName('Bob') //将属性设置在对象自身上。调用原型链上的方法，将p1的name设置为Bob
    console.log(p1)

    let p2 = new Person('Jack',13)
    p2.setName('Cat')
    console.log(p2)


instanceof:P20集说的比较清楚
	如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false；
	A instanceof B //A是一个实例对象(有一个隐式原型__proto__,
				   //隐式原型指后面还有原型对象--即原型链)，

				   //B是一个构造函数对象(函数，即有一个显式原型prototype属性



P21 原型面试题，需要结合C:\Users\Ryen\Desktop\redux ref中的js原型图解去理解
	把这两面试题搞懂原型基本就掌握了；

	理解图解:实例对象看隐式原型__proto__,函数对象看显式原型prototype



变量提升和函数提升:(把变量或函数声明提前执行了)
	
	面试题:变量提升(es6的let必须要先申明才能用，否则报错)
	通过var定义(声明)的变量，在定义语句之前就可以访问到；
	但她的值此时是undefined；
		var a = 3
		function fn() {
			console.log(a)
			var a = 4
		}
		fn() //输出 undefined

	实际代码在解析运行的时候是这样的:
		var a = 3
		function fn() {
			var a
			console.log(a) // 定义但是为赋值 即变量提升
			a = 4
		}
		fn()


	随便在浏览器控制台输入window.b(或其他未定义变量)都会输出undefined；
	可以得出结论全局变量(包括全局函数)都在window里面

	---------
	函数提升:
	通过function声明的函数(表达式函数无法进行函数提升)，在之前就可以直接调用，
	值:函数定义(对象)；

		fn2() //可以调用。函数提升

		function fn2() {
			console.log('fn2')
		}

		fn3()//不能调用，表达式函数无法进行函数提升

		var fn3 = function() {...}


	变量、函数提升都是一种结果，问题在于是什么导致了这个结果？它们是如何产生的？

--------------------------------------

	执行上下文:
		1、代码分类(根据位置)
			*全局代码(对应全局执行上下文)
			*函数(局部)代码---对应局部执行上下文

		执行上下文相当于预处理的操作:在代码执行前，js引擎提前做了些事情
		2、全局执行上下文
			*在执行全局代码前将window确定为全局执行上下文
			*对全局数据进行预处理(其实也是个收集(全局var变量)数据的过程):
				*var定义的全局变量==>赋值为undefined，添加为window属性
				*function声明的全局函数==>赋值为(fun函数对象)，添加为window的方法
				*this==>赋值为(window)
				在代码被执行前浏览器会完成以上步骤
				*执行全局代码

		3、函数(局部)执行上下文:
			*在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象(虚拟的，存在于栈中)
			*对局部数据进行预处理(也可理解为收集数据):
				*形参变量==>赋值为(实参)==>然后添加为执行上下文的属性
				*arguments==>赋值给(实参列表)，添加为执行上下文的属性
				*var定义的局部变量==>赋值为undefined，添加为执行上下文的属性
				*function生命的函数==>赋值给(Function函数对象)，添加为执行上下文的方法
				*this==>赋值给(调用函数的对象)
			*开始执行函数体代码


	--队列:出入口各一个，遵循先进先出规则--
	--栈:出入口共用，遵循后进先出规则--


	执行上下文栈(调用栈):
			1、在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象；
			2、在全局执行上下文(window)确定后，将其添加到栈中(压栈,类似给武器弹夹压子弹)；
			3、在函数执行上下文创建后，将其添加到栈中；
			4、在当前函数执行完后(函数被释放)，将栈顶该函数的执行上下文对象移除(出栈)；
			5、当所有代码执行完后，栈中只剩下window对象(全局上下文/全局变量,这些变量在关闭浏览器的时候才释放)；


			//1. 进入全局执行上下文
	        var a = 10
	        var bar = function(x) {
	            var b = 5
	            foo(x + b)      //3.调用时创建并进入foo函数执行上下文
	        }
	         var foo = function(y) {
	             var c = 5
	             console.table(a + c + y)
	         }

	         bar(10)   //2.调用时创建并进入bar函数执行上下文

			 ----------------
			 *调用一次函数就在栈中创建一个函数执行上下文对象(谁最后被调用/创建，谁就在栈顶，先被执行，执行后该函数执行上下文对象被销毁(出栈))；
			  而全局执行上下文对象会在所有代码执行前创建(关闭浏览器时被销毁)，所以可用n+1表示创建了多少执行上下文对象(n为函数调用的次数,1代表全局执行上下文)

			  fn1(){
			  	fn2()
			  }

			  fn2(){
			  	fn3()
			  }

			  fn3(){
			  	...
			  }

			  fn1() //创建了3个函数执行上下文，和一个全局(window)执行上下文
			  -------------

			  fn1(){
			  	fn2()
			  	fn3() // fn2和fn3的执行上下文不能同时存在，执行fn2时，fn3还没有被调用(函数执行上下文对象没有创建)；执行fn3时，fn2的执行上下文已经释放(出栈)
			  }

			  fn1() //创建了2个函数执行上下文,一个全局执行上下文。n+1规则


			  --------------
			  相关面试题:在p25集
			  	*依次输出什么?
			  		global：undefined
					fb:1
					fb:2
					fb:3
					fe:3
					fe:2
					fe:1
					gb:1

			  	*整个过程产生了几个执行上下文?
			  		产生了5个执行上下文(包括全局的执行上下文)。
			  		注意最先调用的函数执行上下文最先入栈(全局上下文最先入栈，然后是函数体外的foo(i),然后时递归时调用的函数)，
			  		最先入栈的函数执行上下文，最后才被执行。

			  	console.log('global：' + i )
		        var i = 1
		        foo(i) //产生一个函数执行上下文.全局上下文在所有代码执行产生
		        function foo(i) {
		            if( i == 4) {
		                return
		            }
		            console.log('fb:'+ i)
		            foo(i + 1) //每调用一次产生一个执行上下文
		            console.log('fe:' + i)
		        }
		       
		        console.log('gb:' + i)

			-----
			面试题1:
			function f() {}
	        var f;
	        console.log(typeof f) //function 先执行变量提升，再执行函数提升(覆盖前者)

	        -----
	       	面试题2:
	        if(!(b in window)) { //条件不满足没有进入执行
	            var b = 1
	        }
	        console.log(b) //undefined

	        -----
	        面试题3:
	        var c = 1
	        function c(c) {  //如果变量名和函数名不是相同的，报错可以避免
	            console.log(c)
	        }
	        c(2) //报错

	        -----
	        面试题3的代码相当于:
	        var c
	        function c(c) {
	            console.log(c)
	        }
	        c = 1 //变量提升了
	        c(2) //这里c会是一个变量；可以理解成函数c已被变量c覆盖

	复习:
		函数显式原型:
			执行函数定义:
				prototype是属于函数对象的属性。所以的函数都有显式原型属性--prototype；
				只是执行了函数定义，创建了函数对象；函数体并没有执行，在创建函数对象
				的同时，函数对象内部执行了this.prototype={}语句，这里的this就是函数对象，而空对象{}就是原型对象

			执行函数: 函数名() 等于执行函数体

		实例对象隐式原型:
			实例对象分两类:1、函数实例对象(也就是大写Function的实例)；
						  2、new 出来的实例对象(属于Object的实例)

			隐式原型是什么时候产生的:
				在new Cat()创建实例时产生的，同时在new实例的时候会执行一条语句：
				this.__proto__ = Cat.prototype;

		原型链:
			作用：用来查找对象的属性和方法；
			(根据原型链找)打印输出一个对象的属性，如果该属性不存在，会提示undefin，
			(根据作用域链)打印输出一个不存在的变量，会提示报错


		执行上下文与执行上下文栈(代码预处理):
			变量提升和函数提升,是执行上下文与执行上下文栈这个技术的结果；
			变量提升和函数提升，是执行上下文、执行上下文栈产生的一个现象。

			什么是变量提升:
				console.log(a)
				var a = 3, 在这条语句之前输出打印a，会得到undefined，而不是
				报错，这就变量提升。
				
				实际代码执行过程:
				var a //变量a被提升至了代码顶部
				console.log(a)
				a = 3

			什么是函数提升:
				在函数定义之前，就可调用执行函数

			函数和变量谁先提升:
				1、变量先提升，接着是函数提升
				2、函数提升的优先级高于变量，这里的高于指的是函数提升的晚(在变量之后执行提升)


作用域:
	*找变量看作用域/作用域链；找对象属性看原型/原型链;

	*a.b,//去作用域链上去找变量a，如果不存在将报错；若能找从作用域链到a，则确定a的类型是引用对象;
		//然后去该对象的原型链上找b属性(或方法)，如果没找到返回undefined，找到则执行。

	*函数形参属于局部变量。

	1、可以理解为一块“地域”，一段代码所在的区域，
	它是静态的(执行上下文对象则是动态的)，作用域在编写代码时就确定了。	

	2、分类:
		*全局作用域
		*函数作用域(局部作用域)
		*eval作用域，在严格模式下才有
		*ES5没有块作用域(ES6有了)，比如:
			if(true) {
				var c = 3// 这里c被添加到了window，是全局变量
			}

	3、作用:
		*隔离变量，不同作用域下同名变量不会有冲突


	n+1： 和上下文的n+1是一样的，只是这里的n指定是定义了几个函数
	(即每一个局部作用域)，1则代表的是全局作用域

	var a  = 10,
		b = 20 //全局作用域
		function fn(x) { //fn函数作用域
			var a = 100,
				c = 300;
			console.log('fn()',a,b,c,x)

			function bar(x) {//bar函数作用域
				var a = 1000,
					d = 400
					console.log('bar()',a,b,c,d,x) //在当前作用域找不到指定变量时，会从上一级作用域寻找指定变量,直到全局作用域(即作用域链)
			}
			bar(100)
		}
		fn(10)


	作用域和执行上下文的区别和联系:
		区别1：
		*全局作用域之外，每个函数都会创建自己函数作用域，作用域在函数定义时
		就已经确定了，而不是在函数调用确定；
		*全局执行上下文是在全局作用确定之后，js代码马上执行前创建；
		   函数执行上下文环境是在调用函数时，函数体代码执行前创建。

		区别2：
		*作用域是静态的，只要函数定义好就一直存在，且不会在变化；
		*执行上下文是动态的，调用函数是创建，函数调用结束时上下文环境就被自动释放

		关系:
		*执行上下文环境(对象)是从属于所在的作用域
		*全局执行上下文环境==全局作用域
		*函数执行上下文环境==对应的函数作用域

作用域链:
	上面最近的一个例子，636行


作用域面试题:
	1、输出什么:
	var x = 10
	function fn() {
		console.log(x)
	}
	
	function show(f) {
		var x = 20
		f()
	}
	show(fn); //10

	解析:代码有一个全局作用域和两个函数作用域，函数作用域在函数定义的时候就已经确定
	，不会再变，当show函数内的f()执行时，自然是根据已经确定的作用域链去找x变量，对fn函数来说，
	它要找的x变量是上一级作用域链，即要找的是全局作用域中的x变量。

	--------------------

	2、fn2输出什么?

	var fn = function() {
		console.log(fn) //当输出log(fn)时，系统会先从函数内部(局部作用域)
						中找fn变量，没有找到则在全局作用域中找，全局作用域中
						存在fn变量，所以打印输出函数本身。
	}
	fn()

	var obj = {
		fn2:function() {
			console.log(this.fn2) // 正常打印函数本身
			console.log(fn2)//报错，fn2未定义
							当输出log(fn2)时，函数体内没有找到fn2变量,然后
							在全局作用域中找，也没有找到fn2变量，所以报错:
							fn2未定义；
		}
	}
	obj.fn2() 

JS两大神兽 原型和闭包

---函数执行和函数定义执行(后者会产生函数对象)是两码事---

闭包:
	如何产生闭包:
		*当一个嵌套的内部(子)函数引用了嵌套外部(父)函数的变量(或函数)时，并且调用该外部函数(此时闭包产生)

	闭包到底是什么:
		*使用chrome debug调试查看
		*理解一：闭包就是嵌套的内部函数(绝大多数人)
		*理解二：内部函数引用了父函数的变量(或函数) (极少数人)
		*注意：闭包存在于嵌套的内部函数中

	产生闭包的条件：
		*存在函数嵌套
		*内部函数引用了外部函数的数据(变量/函数)
		*执行外部函数


	简单的闭包例子:
		function fn() {
			var a = 8
			function fn2(){ //执行内部函数定义就会产生闭包(不用调用内部函数)；
							//内部函数定义被执行说明外部函数已经被调用了。
							//注意:以函数声明定义的函数存在函数提升。
				console.log(a)
			}
			return fn2
		}
		fn() //执行外部函数才会产生闭包，执行几次外部函数则产生几个闭包


	常见的闭包:
		1、将函数作为另一个函数的返回值(745行)

		P31集第8分钟 有chrome debug调式教程
		function fn1() {
			var a = 7 //当调用该函数，而且代码执行到这行的时候，闭包产生了吗？产生了！
						因为存在函数提升，fn2的函数定义已经被执行，因此已经产生了闭包
			function fn2() { //debug时，在var a = 7处打断点，执行完该断点
								后，指针会直接跳到 return fn2。原因是fn2函
								数的定义已经执行过了，不会再执行一次
				a++
				console.log(a)
			}
			return fn2 //外部函数返回内部函数
		}
		var f = fn1() // 这里调用了外部函数，所以会产生闭包
		f() // 输出3 每调用一次执行一次内部函数
		f() //4  以上代码只产生了一次闭包。在此可以看出闭包的作用，
					外部函数操作了内部函数的局部变量a++(局部变量外部是无法看见的，但通过闭包这个技术能在外部操作局部变量)

		fn1() //再次调用外部函数，会产生第二个闭包
		----------------------------------------------

		2、将函数作为实参传递给另一个函数调用

		function showDelay(mes,time) {
			setTimeout(function() {
				console.log(mes)
			}, time);
		}
		showDelay('iiio')


	闭包的作用:
		1、使用函数内部的变量在函数执行完后，仍然存活在内存中(
			本来函数执行完局部变量就会被释放，所以闭包延长了局部变量的生命周期)

		2、让函数外部可以操作(读写)到函数内部的数据(变量/函数)


		问题:
			1、函数执行完后，函数内部声明的局部变量是否还存在?
				一般不存在，但使用闭包技术后局部变量可能存在(看闭包是否还在被引用)

			2、在函数外不能直接访问函数内部的局部变量吗?
				不能，函数内部变量只有函数自己能看见;但可以通过闭包
				让外部操作它

	闭包的生命周期:
		产生:在嵌套的内部(子)函数定义执行完成时就产生了(注意:不是执行调用函数)

		死亡:在嵌套的内部函数成为垃圾对象时

		function fn1() {
			//此时闭包就已经产生了(因为函数提升，内部/子函数对象已经创建了)
			  但如果子函数是以函数表达式声明写的，那么只有当运行到该函数时，闭包才会产生
			var a = 2
			function fn2() {
				a++
				console.log(a)
			}
			return fn2
		}
		var f = fn1() //f的引用指向的是fn2
		f()
		f()
		f = null // 闭包死亡(原因:包含闭包的函数对象成为垃圾对象)


	闭包的应用:自定义JS模块
		*js模块是具有特定功能的js文件
		*将所有的数据和功能都封装在一个函数内部(私有的（就是指局部变量）)
		*只向外暴露一个包含n个方法的对象，或者直接暴露一个函数。
		*模块的使用者，只需要通过模块暴露的对象调用方法来实现对应用的功能

		下面是myModule.js文件中的代码(模拟一个js模块)
			function myModule() {
			    //私有数据
			    var msg = 'My foot amazing'
			    //操作数据的函数
			    function doSomething() {
			        console.log('doSomething '+msg.toUpperCase())
			    }
			    function doOtherthing() {
			        console.log('doOtherthing '+msg.toLowerCase())
			    }
			    //向外暴露方法(给外部使用的方法)
			    // return doSomething
			    //使用return向外暴露包含多个函数的对象(即暴露多个行为)
			    return {
			        doSomething:doSomething,
			        doOtherthing:doOtherthing
			    }
			}
		----------
		下面是xxx.html文件引入并使用上面的代码:
			<body>
				<script type="text/javascript" src="myModule.js"></script>

				<script type="text/javascript">
					var mod = myModule()
			        mod.doOtherthing() //通过模块暴露的对象，实现闭包操作
			        mod.doSomething()
				</script>
			</body>


		--------------
		使用匿名函数自调用的方式来使用闭包(和上面的例子大同小异):
			//推荐使用这种，因为此模块被别的地方引入后闭包就产生了，
			不用额外执行外部函数。

			(function myModule() {// 使用匿名函数自调用的方式
			    //私有数据
			    var msg = 'My foot amazing'
			    //操作数据的函数
			    function doSomething() {
			        console.log('doSomething '+msg.toUpperCase())
			    }
			    function doOtherthing() {
			        console.log('doOtherthing '+msg.toLowerCase())
			    }
			    //向外暴露对象(给外部使用的方法)
			    // return doSomething
			    //把要向外暴露的函数添加为window的属性
			    window.myModule = {//和上面例子的主要区别在这部分代码
			        doSomething:doSomething,
			        doOtherthing:doOtherthing
			    }
			})()


		html文件中的调用:
			<body>
				<script type="text/javascript" src="myModule.js"></script>
				<script type="text/javascript">
					myModule.doSomething()//区别在这两行代码
			        myModule.doOtherthing()
				</script>
			</body>


	闭包的缺点及解决:
		1、缺点:
			*函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
			*容易造成内存泄漏

		2、解决:
			*能不用闭包就不用闭包(无语了...)
			*及时释放

			function fn1() {
				var arr = new Array(100000) //占用大量内存空间
				function fn2() {
					console.log(arr.length)
				}
				return fn2
			}
			var f = fn1() //不释放对fn2的引用，闭包将一种存在导致内存占用
			f()
			f = null //及时释放闭包，不释放容易导致内存泄漏


		内存溢出和泄漏:
			内存溢出:
				*一种程序运行出现错误
				*当程序运行需要的内存超过了剩余内存时，就抛出内存溢出的错误

				var obj = {}
				for (let i = 0; i < 10000; i++) { //模拟内存不够用的情况
					obj[i] = new Array(10000000)
				}

			内存泄漏(即部分内存空间被占用，长时间没有释放，导致可用内存变小):
	
				*占用内存没有及时释放
				*内存泄漏积累多了就容易导致内存溢出
				*常见的内存泄漏:
					1、意外的全局变量
						function f1(){
							a = 3 //忘记使用var,导致了一个全局变量
							console.log(a)
						}
					2、没有及时清理的计时器或回调函数
					3、闭包

	面试题:
		代码片段1:
		var name = 'window'
		var object = {
			name:'my object',
			getNameFunc:function() {
				console.log(this.name) //my object
				return function() {
					return this.name //不存满足闭包条件:没有调用外部函数的变量
				}
			}
		};
		alert(object.getNameFunc()()); //?输出window，
									   //原因:object.getNameFunc()执行后得到的是一个函数(此时this的值是object)
										//后面那个括号执行了这个返回的函数(类似在全局作用域中这样调用:fn())，此时的this指向window


		-----------------------------------------------------
		代码片段2：
		var name2 = 'the window'
		var object2 = {
			name2:'my object',
			getNameFunc:function() {
				var that = this //保存的this是在object2调用getN...函数的this(自然指向obj2)
				return function() {
					return that.name2 //满足闭包条件
				}
			}
		};
		alert(object2.getNameFunc()())//my object
									  //执行调用第一个函数时，this自然是指向obj2的，外部函数此时会将this存为一个变量，
									  //后面括号执行的是getNa...返回的函数，该函数使用了外部函数的that变量(存的是指向obj2的this)

	终极面试题:p41集
		function fun(n,o) {
			console.log(o)
			return {
				fun:function(m) {
					return fun(m,n) //每次调用外部函数都会产生新闭包，
									//下面的代码要注意调用者有没有将新产生的闭包对象保存为一个变量作为后续的使用
				}
			}
		}
		var a = fun(0) //输出undefined;
		a.fun(1) //0 
		a.fun(2) //0
		a.fun(3) //0 产生了新的闭包，但马上消失了，因为这里没有将每个新产生的闭包对象保存为一个变量
		// var xxx = a.fun(1) //将新产生的闭包对象保存下来。每次调用内部函数都会产生新闭包(因为内部函数体调用了外部函数)

		var b = fun(0).fun(1).fun(2).fun(3) // undefined,0,1,2。
		//执行fun(0)时，fun(n=0,o=undefined)所以输出undefined，注意此时闭包n值为0；
		//执行fun(1)时，fun(m=1),然后调用外部函数fun(m=1,n=0)>>fun(n=1,o=0)，所以输出0。注意此时闭包n值变为1；
		//执行fun(2)时，因上一次闭包n的值是1，所以fun(m=2,n=1)因此，fun(n=2,o=1),所以fn(2)输出1。此时n值变为2
		//执行fun(3)。。。。

		//每调用一个fun(x)，都会将产生新闭包对象，并保存该闭包的引用，后面的fun(x)都是在前面闭包的基础上调用的，

		//var b = fun(0).fun(1).fun(2).fun(3)相当于
		// var b = fun2(0)
		// var c1 = b.fun(1)
		// var d = c1.fun(2)
		// var e = d.fun(3)

		var c = fun(0).fun(1) //执行fun(0),fun(n=0,o=undefined)所以输出undefined，注意此时闭包n值为0
							  //执行fun(1),fun(m=1),fun(m=1,n=0)>>fun(n=1,o=0)，此时闭包n值为1
		c.fun(2)// 变量c的引用的是fun(1)产生的闭包，n值为1，所以后面两个输出1,1
		c.fun(3)//undefined,0,1,1



面向对象高级:
对象创建模式:
	1、Object构造函数模式
		*套路:先创建空Object对象，再动态添加属性/方法
		*适用场景:起始时不确定对象内部数据
		*问题:语句太多

		比如构建一个person对象:
		var p = new Object()
		p.name = 'tom'
		p.age = 12
		p.setName = function(name) {
			this.name = name
		}


	2、对象字面量模式
		*套路：使用{}创建对象，同时指定属性/方法
		*使用场景：起始时对象内部数据是确定的
		*问题：如果创建多个对象，会重复代码

		如:
		var p = {
			name:'jack',
			age: 13,
			setAge:function(age) {
				this.age = age
			}
		}

	3、工厂模式
		*套路：通过工厂函数动态创建对象并返回
		*使用场景：需要创建多个对象
		*缺点：对象没有一个具体的类型，都是Object类型

		例如:
			function createPerson(name,age) { //返回一个对象的函数都是工厂函数
				var obj = {
					name:name,
					age:age,
					setName:function(name) {
					this.name = name
					}
				}
				return obj
			}

			//创建多个人
			var p1 = createPerson('kk',22)
			var p2 = createPerson('aa',29)

		工厂模式的缺点:
			function createStudent(name,price) {
				var obj = {
					name:name,
					price:price
				}
				return obj
			}

			var s = createStudent('丽丝',12000)

			p1/p2是Object类型，s也是Object类型；
			没法区分具体类型(有时候创建/使用对象时需要知道具体类型)

	4、自定义构造函数模式
		*套路：自定义构造函数，通过new创建对象
		*使用场景：需要创建多个类型确定的对象
		*缺点：每个对象都有相同的数据(例如方法)，浪费内存

		例如：
			//定义类型
			function Person(name,age) {
				this.name = name,
				this.age = age,
				this.setAge = function(age) {
					this.age = age
				}
			}

			var p1 = new Person('by',21)
			p1.setAge('jack')
			console.log(p1.name,p1.age)

			解决了工厂模式的缺点:
			function Student(name,price) {
				this.name = name,
				this.price = price
			}
			var s = new Student('bob',10000)
			//每个对象都有自己的类型
			console.log(s instanceof Student)//true
			console.log(p1 instanceof Student)//true


	5、构造函数+原型的组合模式
		*套路：自定义构造函数，属性在函数初始化，方法添加到原型上
		*使用场景：需要创建多个类型确定的对象

		如:
			function Person(name,age) {//在构造函数中只初始化一般函数
				this.name = name,
				this.age = age,
			}

			Person.prototype.setName = function(name) { //将方法添加到对象的原型上
				this.name = name
			}

			var p1 = new Person('by',21)
			var p2 = new Person('jack',18)
			console.log(p1,p2)



在js中实现继承:
	1、原型链的继承(p38集，有点繁琐，15分钟后开始画图)
		套路：
			1、定义父类型构造函数
			2、给父类型的原型添加方法
			3、定义子类型的构造函数
			4、创建父类型的对象赋值给子类型的原型
			5、将子类型原型的constructor设置/指向为子类型
			6、给子类型原型添加方法
			7、创建子类型的对象：可以调用父类型的方法
		*关键：
			子类型的原型为父类型的一个实例对象

		//步骤1---定义父类型
		function Supper() {
			this.supPro = 'Supper property'
		}
		//步骤2
		Supper.prototype.showSuppeProp = function() {
			console.log(this.supProp)
		}//给父类型的原型添加方法

		//步骤3---定义子类型
		function Sub() {
			this.subProp = 'Sub property'
		}

		//关键--》子类型的原型为父类型的一个实例对象
		Sub.prototype = new Supper()
		//让子类型的原型的constructor指向子类型(构造函数)
		Sub.prototype.constructor = Sub

		Sub.prototype.showSubProp = function() {
			console.log(this.subProp)
		}//step4给子类型的原型添加方法

		var sub = New Sub()
		sub.showSupperProp()


	2、借用构造函数继承(假继承)
		1、套路：
			*定义父类构造函数
			*定义子类构造函数
			*在子类型的构造函数中调用父类型的构造
		2、关键：
			*在子类型构造函数中通过call()调用父类型构造函数

		function Person(name,age) {
			this.name = name
			this.age = age
		}

		function Student(name,age,price) {
			Person.call(this,name,age)//相当于：this.Person(name,age)
			也相当于这两行代码
			//this.name = name
			//this.age = age
			this.price = price
		}
		var s = new Student('jack',20,15000)
		console.log(s.name,s.age,s.price)


	3、组合继承(原型链+借用构造函数的组合继承，即融合以上两种方式)
		*利用原型链实现对父类型对象的方法继承
		*利用call()借用父类型构造函数初始化相同属性

		function Person(name,age) {
			this.name = name
			this.age = age
		}

		Person.prototype.setName = function(name) {
			this.name = name
		}

		function Student(name,age,price) {//即上面的第2种继承方式
			Person.call(this,name,age) // 为了得到父类型的属性
			this.price = price
		}

		Student.prototype = new Person() //为了能看到父类型的方法
										 //即上面的第1种继承方式
		Student.prototype.constructor = Student//修正constructor属性
		Student.prototype.setPrice = function(price) {
			this.price = price
		}
		var s = new Student('jack',20,16000)
		s.setName('ryan')
		s.setPrice(13000)
		console.log(s.name,s.age,s.price)

线程机制与事件机制(p43开始介绍了浏览器相关的内容):
	进程与线程:
		进程是程序/应用的一次运行，占有一片独有的内存空间。
		线程是进程内的一个独立执行单元，是cpu的最小调度单元。

	js是单线程还是多线程？
		js是单线程的；
		但使用H5的Web Workers可以多线程运行

	浏览器运行是单线程还是多线程？
		无论什么浏览器都是多线程运行的

	浏览器运行是单进程还是多进程？
		有单进程的也有多进程的
		多进程如chrome、新版IE；单进程的有fireFox、老版IE

	浏览器主线程运行:
		js代码都是在主线程执行的。
		浏览器内核:
			支撑浏览器运行的最核心的程序

			js引擎(也是代码):负责js程序的编译和运行

		html,css文档解析模块，负责页面文本解析

		DOM/CSS模块：负责dom/css在内存中的相关处理

		布局和渲染模块：负责页面的布局和效果的绘制

	浏览器分线程运行:
		定时器模块：负责定时器的管理
		事件响应模块：负责事件管理
		网络请求模块：负责ajax请求

	定时器引发的思考:
		1、定时器并不能保证真正定时执行
		2、一般会延迟一丁点(可以接受)，也有不可接受的延迟很长时间

		3、定时器回调函数是在主线程执行的，js是单线程
		4、定时器是根据--事件循环模型(后面讲)--实现的

		var start = Date.now()
		console.log('启动定时器执前')
		setTimeout(() => {
			console.log('定时器执行了' ,+ Date.now() - start)
		}, 200);
		console.log('启动定时器执后')


	如何证明js是单线程的(p45集):
		*setTimeout()的回调函数是在主线程执行的
		*定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行

		*js之所以设计成单线程，与它的用途有关
		*作为浏览器脚本语言，js的主要用途是和用户互动以及操作DOM
		*这决定了它只能是单线程，否则会带来很复杂的同步问题

		代码分类:
			*初始化代码
			*回调代码

		js引擎执行代码的基本流程:
			先执行初始化代码:包含一些特别的代码
				*设置定时器
				*绑定监听
				*发送ajax请求
			后面在某个时刻才会执行回调代码


	事件循环模型:
		p46-p48未看


	JS Error:
		https://www.bilibili.com/video/BV1WE411P7e6?p=5&spm_id_from=pageDriver

		错误类型:
			Error：所有错误的父类型
			ReferenceError：引用的变量不存在
			TypeError:数据类型不正确
			RangeError：数据值不在其所允许的范围内
			SyntaxError:错误语法

		错误处理:
			捕获错误:try ... catch
			程序员自己排除错误：throw error

		错误对象：
			message属性，错误相关信息
			stack属性，函数调用栈记录信息


	实例对象和函数对象:
		https://www.bilibili.com/video/BV1WE411P7e6?p=2

		1、实例对象:new 函数产生的对象，称为实例对象;

		2、函数对象(在ES6称作类对象/类的静态成员)，将函数作为对象使用时，
		  简称为函数对象(函数可以作为函数使用，也可以作为对象使用)

		3、实例对象和函数对象的属性/方法是不共用的

			function Fn(){ //Fn函数

			}
			const f = new Fn()//Fn构造函数
			console.log(Fn.prototype)//Fn本身是个函数，但此时被当作对象在用
						 //此时Fn就是个函数对象

			Fn.bind(...)//调用函数对象的bind方法,Fn就是函数对象

			$('#test')//jQuery函数

			$.get('url')//jQuer函数对象


		4、在ES6类中定义的静态成员(相当于ES5的函数对象)
			不属于实例对象，是属于类的:
			class xx{
				static reject = function() {....}
				或者:
				static function reject() {....}
			}



		扩展:
			.的左边是对象(分实例对象/函数对象);
			 ()的左边的函数;



-----------------------------------------------END---------------------------------------------------


ES6:
https://www.bilibili.com/video/BV1uK411H7on?p=4&spm_id_from=pageDriver


	ECMA(European Computer Manufacturers Association)欧洲计算机制造协会，
	1994年后该组织改名为Ecma国际
	什么是ECMAScript？
		ECMAScript是由ECMA国际通过ECMA-262标准化的脚本程序设计语言

	ECMA-262是什么:
		ECMA-262是ECMA国际制定众多标准中的其中一个

	谁在维护ECMA-262:
		TC39(Technical Committee 39)是推进ECMAScrript发展的委员会，其会
		员都是公司(主要是浏览器厂商，苹果、谷歌、微软等)

	2015年，ECMAScript6 发布，随后更名为ECMAScript2015，即ES6；

	ECMAScript2018即ES8，但ES8的语法现在(2020)可能还不能用,因为浏览器厂商没有去实现新的
	语法规定，即使编码者写出的ES8语法的代码浏览器(如chrome的v8 js脚本引擎)也无法执行。

	通过编译器babel，可将ES6代码编译成ES5代码，以解决某些浏览器兼容的问题


let关键字:
	let不能重复声明(赋值)；
	；var可重复赋值(后者会覆盖前者)；

	如果在全局作用域中用var声明变量，此变量会默认成为window的一个属性，let声明的变量则不会被添加到window对象中

	let属于块级(if/for/else...等){}作
	用域，在块外访问块内的变量将报错:
		{let girl = 'yy'}
		...log(girl) //报错，代码块外无法访问

	不能变量提升：
		let不能变量提升。
		ES5可以先使用变量稍候再定义变量而不会引发异常，这个概念就是变量提升，ES6的let，const不存在变量提升.

	不影响作用域链:
		例如:
			{
				let school = '水中'
				function fn() {
					console.log(school)
				}
				fn() //水中
			}


	let经典案例:

		<body>
			<div>
				<h2 class='page-header'>点击切换颜色</h2>
				<div class='item'>00</div>
				<div class='item'>11</div>
				<div class='item'>22</div>
			</div>
			<script type="text/javascript">
				let items = document.getElementsByClassName('item')

				for (var i = 0; i < items.length; i++) {
					items[i].onclick = function() { //为每个元素绑定事件回调函数
						// this.style.background = 'pink'
						items[i].style.background = 'pink'//将报错
					}
				}

				//因为var i不属于块级作用域，属于全局变量；循环结束后i自增最后结果是3 ；
				//当我们去点击某一个div块时，会触发执行回调函数，函数体内找不到变量i，
				//会去全局变量里面找，window下面有i=3，而因为items下标值最大为2[0,1,2]
				//因而函数体内地代码，最终无法达到预期效果，将var i=0换成let i=0即可
			</script>
		</body>


const关键字:
	用来定义常量。值不能修改的量称为常量。

	1、const在定义常量时一定要赋初始值。
	2、用const的变量名一般用大写，但这不是语法要求
	3、常量的值不能修改
	4、const属于块级，这点是和let一致的
	5、对于数组和对象的元素修改，不算做对常量的修改，不会报错
		(因为修改的是对象或数组的内容，而不是修改他们的地址值)


解构赋值:
	*按照一定模式从数组和对象中提取值，再对变量进行赋值

	1、数组的解构
		const F4 = ['小沈阳','刘能','赵四','小宝']

		let [x,l,z,b] = F4
		console.log(x,l,z,b)

	2、对象的解构
		const Z = {
			name:'子龙',
			age:19,
			asset:'花果山',
			size:'18',
			fn:function() {
				console.log('函数:我可以飞天')
			}
		}

		let {name,age,asset,size,fn} = Z

		console.log(asset)
		console.log(size)
		fn()


模板字符串:
	ES6引入新的声明字符串的方式(ES5有''和"")

	1、声明:
		let str = `我也是一个字符串!`
		console.log(str, typeof str)

	2、特性:内容中可以直接出现换行符
		let str = `<ul>
						<li>康熙</li>
						<li>雍正</li>
						<li>乾隆</li>
						<li>顺治</li>
					</ul>`

		如果使用单双引号需要用+号拼接

	3、变量拼接:
		let love = '四镇多异心'
		let out = `${love}诸王无寸土` //必须使用${}

		console.log(out)

	4、简化对象写法(减少程序员做重复的事)
		ES6允许在大括号里，直接写入变量和函数，作为对象的属性和方法
		(让代码更简洁)

		let name = 'king'
		let change = function() {
			console.log('少干重复的活')
		}

		const school = { //简化对象写法
			name,
			change, //直接在放入放入变量名，可以不用key:value形式了
			myTest() { //可直接定义函数；去除每次都要写的:和function
				console.log('ES6让我减少了多余的语法')
			}
		}
		school.myTest()


箭头函数:

	let fn = (a,b) => {
		console.log(a+b)
	}

	在箭头函数出现之前，每一个新函数都重新定义了自己的 this 值（在构
	造函数中this值就是那个新的对象；在严格模式下this是未定义的；
	对普通函数，谁调用函数this就指向谁）

	1、箭头函数的this是静态的，其this始终指向函数声明时所在的作用域下(外)的this的值
	   无论用call()或apply()等等方式去改变，箭头函数的this指向都是不会变的

	   function fn1() {
			console.log(this.name)
		}

		const fn2 = () => {
			console.log(this.name)
		}

		//设置window对象的name属性
		window.name = '我是全局属性'

		const tri = {
			name:'方知'
		}

		//直接调用
		// fn1()
		// fn2()

		//call方法调用
		fn1.call(tri) //将fn1当作tri对象的方法进行调用，this的值指向tri对象
		fn2.call(tri) //this指向不会因为call方法改变，依旧输出window.name的值

	2、箭头函数不能作为构造函数使用
	3、不能使用arguments变量
	4、箭头函数简写:
		*当形参只有一个的时候,可以省略小括号:
			let ff = a => {。。。}

		*当函数体只有一条语句的时候，可以省略花括号和return关键字:
			let test = n => n*n


	5、箭头函数的实践:
		*箭头函数适合与this无关的回调，如定时器，数据的方法回调
		*箭头函数不适合与this有关的回调，如事件回调或作为对象的方法



函数参数的默认值:
	ES6允许给函数形参赋值初始值

	1、需要注意，具有默认值的形参，一般位置要靠后(潜规则)
	2、可以和解构赋值结合使用

	function add(a,b,c=10) {
		console.log(a+b+c)
	}

	add(1,2)//c没有传入参数时，默认使用初始值


rest参数(即剩余参数):
	用于获取函数的实参，用来代替arguments

	1、ES5用arguments获取实参的方式:

		function date() {
			console.log(arguments)
		}

		date('对A','抢地主','王炸')
		-----------------------

	2、ES6的rest参数：

		function date(...a) {
			console.log(a)
		}

		date('对A','抢地主','王炸')


	3、rest参数和arguments的区别:
		rest返回的是一个数组；
		arguments返回的是一个伪数组，实际上就是对象

	4、rest参数必须放到最后

		function fn(a,b,...c) {
			console.log(a)
			console.log(b)
			console.log(c)
		}

		fn(1,2,4,6,7,8,9,5)


扩展运算符:
	扩展运算符能将数组转换为逗号分隔的参数序列

	const boy = ['food','hot','sky']

	function chunwan() {
		console.log(arguments)
	}

	chunwan(...boy) //相当于chunwan('food','hot','sky')


	扩展运算符和rest参数长得很像，但他们是不一样的，
	rest参数是放在了函数形参的位置，但扩展运算符是放在
	调用函数时实参位置


	扩展运算符的应用：
		*可用于数组合并
		*数组的克隆/复制
		*将伪书组转为真正的数组


symbol:
	ES6引入的一种新的原始数据类型Symbol，表示独一无二的值，他是js语言的
	第七种数据类型，是一种类似于字符串的数据类型

	特点:
		*symbol的值是唯一的，用来解决命名冲突的问题
		*symbol值不能与其他数据进行运算
		*symbol定义的对象属性不能使用for...in循环遍历，但可用
			Reflect.ownKeys来获取对象的所有键名


	创建方式:
		let s = Symbol()
		console.log(s,typeof s)

		let s2 = Symbol('鸡米')
		let s3 = Symbol('鸡米')
		console.log(s2 === s3) //false

		let s4 = Symbol.for('一条')
		let s5 = Symbol.for('一条')
		console.log(s4 === s5) //true

	USONB=undefined,string,symbol,object,null,number,boolean


	symbol的使用:
		在对象中添加symbol类型的属性:
			let game = { //假设这是一个复杂对象，其中有很多属性方法，
						 //为了避免属性名重复，可以定义Symbol类型的属性/方法
				up:function() {
					console.log('俄罗斯方块')
				},
				down:function() {
					console.log('原始')
				}
			}
			let methods = {  //在methods对象添加两个Symbol类型的属性
				up:Symbol(),
				down:Symbol()
			}

			game[methods.up] = function() { //向game添加Symbol类型的方法
				console.log('改变形状')
			}

			game[methods.down] = function() {
				console.log('我可以降落')
			}
			console.log(game)

			//---------------------------------
			//另一种向对象添加Symbol类型属性的方式
			youxi = {
					name:'狼人杀',
					[Symbol('say')]:function() { //对象属性的key不可以直接用Symbol()，需要用中括号
						console.log('我可以发言')
					}
				}

			console.log(youxi)


	Symbol内置属性:
		*用来控制对象在特定场景下的表现

		除了处理定义我们自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部的使用方法

			Symbol.hasInstance:当其他对象使用instanceof运算符，判断是否为
			该对象的实例时，会调用该方法。

			...


迭代器(Iterator):
	
	(19part)https://www.bilibili.com/video/BV1uK411H7on?p=19&spm_id_from=pageDriver

	*iterator是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构
	 只要部署iterator接口，就可以完成遍历操作。

	 *在JS中，iterator接口指的就是某些对象中属性

	*ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of使用

	*JS原生s实现/具备iterator接口的数据(对象)(即可以for of遍历的类型):
		1、Array
		2、Arguments
		3、Set
		4、Map
		5、String
		6、TypedArray
		7、NodeList

	例如:
		const arr = ['隋','唐','宋','元','明','清']
		for (const i of arr) {//使用for of迭代输出的是对象属性的值
			console.log(i)
		}

		for (const i in arr) {//使用for in迭代输出的是对象属性的键
			console.log(i)
		}

		arr.forEach(i => {//使用forEach迭代输出的是对象属性的值；可以对
						  //属性进行修改，for of不行
			console.log(i)
		});

		数组类型的数据为什么能实现迭代呢？
			因为Array实现了iterator接口，在Array的原型链中可以看到
			Symbol(Symbol.iterator)属性，重写对象的Symbol.iterator
			属性，可以自定义遍历数据


生成器函数:
	*生成器函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同

	*生成器就是一个特殊的函数

	创建:
		function * gen() {
			console.log('第1次执行')
			yield '四镇多异心' //yield关键字可以看成是函数代码的分割符
							  //yield后面可以跟一个字面量/变量或表达式
			console.log('第2次执行')
			yield '两岛囤师' 
			console.log('第3次执行')
			yield '敢向东南争半壁' 
			console.log('第4次执行')
			yield '诸王无寸土'
			console.log('第5次执行')
			yield '一隅抗志'
			console.log('第6次执行')
			yield '方知海外有孤忠'
		}

		let iter = gen() //直接调不会执行
		// console.log(iter)
		iter.next(); //调用它的next函数才会执行生成器函数
		iter.next(); //每调用一次执行一次yield划分的代码块
		iter.next();
		iter.next();

		for(let v of gen()) {
			console.log(v)
		}


	生成器函数的参数传递:

	生成器函数实例:
		讲得太枯燥了


Promise：

	*主要用来实现封装数据库IO，文件、网络IO的异步操作

	Promise的使用:
		//实例化Promise对象，构造器接受一个执行器函数
		//Promise对象有三个状态属性(初始化、成功、失败)
		const p = new Promise(function(resolve,reject) {//执行器函数是一个同步回调，resolve()和reject()也是同步代码
			//异步业务代码
			let data = '数据库中用户数据'
			setTimeout(() => {
				//业务成功则调用resolve函数
				resolve(data) //调用resolve函数，会使当前promise对象状态改为fulfilled
			}, 1000);

			if(1===2) {
				//调用reject函数，会使当前promise对象状态改为rejected
				reject('业务失败了')
			}

		})
	
		//上面的异步操作完成后，调用promise对象的then方法(接收两个回调函数为参数)
		p.then(function(val){ //成功调用第一个函数
			console.log(''+val)
		},function(err){//失败调用第二个函数
			console.log(err)
		})


	p26集:用Promise封装Ajax请求:

		<script>
			//创建ajax对象
			const xhr = new XMLHttpRequest();
			//初始化
			xhr.open('get','https://api.apiopen.top/getJoke')

			xhr.send()

			xhr.onreadystatechange = function() {//绑定回调事件，
												 //处理返回结果
				if(xhr.readyState === 4) {//响应是否全部返回
					if(xhr.status >= 200 && xhr.status < 300) {
						console.log(xhr.response)
					}else{
						console.log("发生错误: " + xhr.status)
					}

				}
			}
		</script>

		promise封装后的ajax，注意他们的区别，上面的代码直接在ajax中绑定了回调结果并处理了数据；
		而promise封装后，在拿到结果后调用then方法对数据进行处理(在复杂场景中promise比较有优势)

		<script>
			const p1 = new Promise(function(resolve,reject) {
				//创建ajax对象
				const xhr = new XMLHttpRequest();
				//初始化
				xhr.open('get','https://api.apiopen.top/getJoke')

				xhr.send()

				xhr.onreadystatechange = function() {//处理返回结果
					if(xhr.readyState === 4) {//响应数据是否全部返回
						if(xhr.status >= 200 && xhr.status < 300) {
							resolve(xhr.response)
						}else{
							reject(xhr.status)
						}
					}
				}
			});
			//为promise对象指定成功或失败的回调(在回调函数中对数据进行操作)
			p1.then(function(value) {
				console.log(value)
			},function(err) {
				console.log("发生错误: " + err)
			})
		</script>


	Promise的链式回调:
		p28集
		p30开始没看了，讲的不够深入



	------------------------

	https://www.bilibili.com/video/BV1454y1R7vj?p=4&spm_id_from=pageDriver(此系列对promise讲的比较好)

	(p7集)Promise的then方法：
		*then方法返回的结果是一个新Promise对象，新对象(初始状态是pending)
		  的状态和值由当前then方法中的回调函数的return结果决定

			*注意then()中的两个参数是回调函数，可能是异步执行的(如果函数体里面有异步代码的话)，
				也就是说promise的状态确认后，也可能不是马上就执行这两个回调函数的

		*promise的状态不改变，不会执行then里的回调函数:
			new Promise(function(resolve,reject) {
				
			}).then(val => {
				console.log('success')
			},err => {
				console.log('war')
			})

		*在then方法中，新promise状态由then的失败或成功回调函数的结果决定

			const p2 = new Promise(function(resolve,reject) {
					resolve()
				})

				const th = p2.then((val) => {
					console.log('success：'+val);
					return 123 //返回的新的promise对象为成功
				},(err) => {
					console.log('err：'+err)
				})
			
				th.then(value => {
					console.log('成: '+value);
				}, err => {
					console.log('败: '+err);
				})
				console.log(th) //th实例的promise状态为fulfilled


	promise的catch方法:
		const p = new Promise((resolve,reject) => {
			//这里的空间就是promise的执行体
			// reject('失败')
			// resolve('success')
			throw new Error('出错了')//当前状态为pending时抛出错误，状态变为rejected
		})

		//catch中的参数函数在什么时候执行?
		//1、当promise的状态改为rejected时，被执行
		//2、当promise执行体中出现错误代码时，被执行
		//3、当promise执行体中抛出错误时
		p.catch(war => {
			console.error(war)
		})
		console.log(p)

		catch方法和then方法的第二参数(失败回调函数)，功能是一样的，
		都是promise的状态返回rejected时调用。

		//推荐写法:then方法只写第一个参数(成功回调函数)，第二个参数不写，
		//用catch方法替代then的第二个参数(这样就只要写成功回调即可，只要
		//有一个promise对象状态为失败，就会被catch捕获)

		new Promise((resolve,reject) => {
				
			}).then(value => {
				//成功时执行
			}).catch(err => {
				//失败/错误时执行
			})


	promise的函数对象方法all:
		const p1 = new Promise((resolve,reject) => {
			resolve(1)
		})

		const p2 = Promise.resolve(2) //直接返回成功的promise对象
		const p3 = Promise.reject(3) ////直接返回失败的promise对象
		p2.then(val => {console.log(val)})

		p3.catch(war => {console.warn(war)})//onRejected写法1
		p3.then(null,error => {console.log(error)})//onRejected写法2

		//all方法接收多个promise对象作为参数，相当于发起多个异步/同步操作，
		//只有当all函数中所有的promise对象都返回成功pAll的状态才是成功，
		//只要all函数中的promise对象有一个是rejected的，当前promise的状
		//态就是rejected

		// const pAll = Promise.all([79,p1,p2])//可接收非promise对象的参数(race()也一样)
		// const pAll = Promise.all([p1,p2,p3])
		const pAll = Promise.all([p1,p2]) 								
		pAll.then(success => {
			//若所有promise返回成功，则以数组的形式返回结果，
			//返回结果的顺序和all方法中的参数顺序一致
			console.log(success)
		}).catch(err => {
			console.log(err) //输出对应promise对象rejected的值
		})


	promise的函数对象方法race:

		<script>
			const p1 = new Promise((resolve,reject) => {
				resolve(1)
			})

			const p2 = Promise.resolve(2) //直接返回成功的promise对象
			const p3 = Promise.reject(3) ////直接返回失败的promise对象

			//race方法接收多个promise对象作为参数，相当于发起多个异步/同步操作，
		    //当前promise实例(pRace)的状态取决于race函数中最先完成的
			//promise；
			//race函数最终只会返回一个promise对象的状态，即:参数中谁最快
			//执行完，就取该promise的状态为当前promise实例状态(谁快用谁)

			const pRace = Promise.race([p1,p3,p2]) 								
			pRace.then(success => {
				//这里最快返回的是race的第一个参数，状态是resolve，
				//所以会执行成功回调(如果给p1设置延迟，p3是最快的，
				//到时会执行pRace的失败回调)
				console.log('onResolve:' + success)
			}).catch(err => {
				console.warn('onRejected:' + err)
			})
		</script>



	Promise的理解和使用:
		https://www.bilibili.com/video/BV1WE411P7e6?p=6&spm_id_from=pageDriver

		promise是什么:
			抽象表达：
			promise是js中进行异步编程的新的解决方案

			具体表达：
				*从语法上来说，Promise是一个构造函数
				*从功能上来说，Promise对象用来封装一个异步操作并可以
					获取其结果

		(P10集)promise的优势:
			1、指定回调函数的方式更加灵活:
				*旧的回调方式:必须在启动异步任务前指定
				*promise:启动异步任务，》》返回promise对象》》给promise对象
				  绑定回调函数(then)

			2、支持链式调用，可以解决回调地狱问题
				*回调地狱：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套
				 的回调函数执行的条件

				 *回调地狱的缺点，不便于阅读、调试和异常处理

				 解决方案:promise链式调用；
				 终极解决方案:async/await

	Promise比较常见的疑问:
		*Q：一个promise实例指定多个成功/失败回调函数，都会调用吗？
		  A:promise改变为对应状态时，都会调用。

		  const p1 = new Promise((resolve,reject) => {
				resolve(1)
			})
					
			p1.then(success => {
				console.log('onResolve1:' + success)
			}).catch(err => {
				console.warn('onRejected1:' + err)
			});
			
			p1.then(val => {
				console.log('onResolve2:' + val)
			}).catch(meg => {
				console.warn('onRejected2:' + meg)
			})


		Q:改变promise状态和指定回调函数谁先执行？
		A：*都有可能，正常情况下是先指定回调函数再改变状态，但也可以先改变状
			态再指定回调
		   *如何先改变状态再指定回调？
		   		1、在执行器中直接调用resolve()或reject()
		   		2、延迟更长时间后才调用then()中的回调函数

		   *什么时候才能得到数据:
		   		1、如果先指定回调，那当状态发生改变时，回调函数就会调用，得到数据
		   		2、如果先改变状态，那当指定回调函数时，回调函数就会调用，得到数据


		   	//常规:先指定回调函数(then的两个参数)，后改变状态
		   	new Promise((resolve,reject) => {
				setTimeout(() => {
					resolve(1)//后改变状态，同时指定数据；异步执行回调函数
				}, 1000);
			}).then(success => {//先指定回调函数，并且保存当前的回调函数(供promise状态确认后调用)
				console.log('onResolve1:' + success)
			}).catch(err => {
				console.warn('onRejected1:' + err)
			});


			//如何先改变状态，后指定回调函数:
			new Promise((resolve,reject) => {
					resolve(1)//先改变状态，同时指定数据
			}).then(success => {//后指定回调函数，执行回调函数
				console.log('onResolve1:' + success)
			}).catch(err => {
				console.warn('onRejected1:' + err)
			});

			--------
			const p = new Promise((resolve,reject) => {
				setTimeout(() => {
					resolve(1)//先改变状态，同时指定数据
				}, 1000);
			})

			setTimeout(() => {
				p.then(val => {console.log('val: ' + val)},
				reason => {console.log('reason: ' + reason)}
				)
			}, 1100);


		-----------------------------------------------------------------------
		https://www.bilibili.com/video/BV1WE411P7e6?p=16&spm_id_from=pageDriver

		Q:promise.then()返回的新promise的状态由什么决定?

		A:
			1、简单表达，由then()指定的回调函数执行的return结果决定
			2、详细表达:
				*如果抛出异常，新promise变为rejected，结果值reason就为抛
					出的异常

				*如果return的是非promise的任意值，新promise状态则变为resolved，val
					ue为返回值

				*如果return的是另一个新promise，此promise的结果就会成为新
					promise的结果(如:Promise.resolve(1))

			总结:then()返回新promise状态为rejected的唯二情况:
				 1、成功或失败回调函数throw出一个异常；
				 2、成功或失败回调函数return一个失败状态的promise对象

			总结:then()返回新promise状态为resolved的唯二情况:
				 1、成功或失败回调函数return的是非promise的任意值
				 2、成功或失败回调函数return一个成功状态的promise对象


			new Promise(function(resolve,reject) {
				//这里产生的状态只影响决定第一个then执行(成功/失败)回调函数
				resolve(1)
				//reject(2)
			})
			.then((val) => {
				//如果什么也不return，下一个then的成功回调会被调用，新promise状态为成功，value值为undefined

				console.log('success: '+val);

				return 2//下一个then的成功回调被调用，新promise状态为成功，value为2

				//return Promise.resolve(6)//下一个then的成功回调被调用，新promise状态为成功，value为6

				//return Promise.reject(7)//下一个then的失败回调被调用，新pro状态为失败，reason为7

				//throw 8//下一个then的失败回调被调用，新promise状态为失败，reason为8

			},(err) => {

				console.log('err: '+err)

				//根据每一个then的回调函数都会产生一个新promise对象的规则。下一个then执行哪个回调函数
				//取决于当前then的(成功/失败)回调函数return的值；并不是执行了当前then的失败回调下一个then就会调用
				//它的失败回调函数.

				//成功/失败回调函数的return值即代表了当前then返回的新promise的状态和所传的值，这就是下一个
				//then执行失败或成功回调的依据和数据；
				
				//如果什么也不return，下一个then的成功回调会被调用，新promise状态为成功，value值为undefined

				return 2//下一个then的成功回调被调用，新promise状态为成功，value为2

				//return Promise.resolve(6)//下一个then的成功回调被调用，新promise状态为成功，value为6

				//return Promise.reject(7)//下一个then的失败回调被调用，新pro状态为失败，reason为7

				//throw 8//下一个then的失败回调被调用，新promise状态为失败，reason为8
			})

			.then(value => {//改then的回调由上一个promise的回调函数决定，
				console.log('成: '+value);
			}, reason => {
				console.log('败: '+reason);
			})
			

		--------------------------------------------------------

		promise可以串联操作多个同步/异步任务。
		*使用链式调用时，在then的回调函数中，同步操作可以直接return，
		  同步代码的结果将自动封装成promise对象，异步操作需要自
		  	己封装在promise内，才能得到异步操作的结果


		  	new Promise(function(resolve,reject) {
					resolve(1)
				})

				.then((val) => {
					console.log('p1 success: '+val);
					return 3
				},(err) => {
					console.log('p1 err: '+err)				
				})

				.then(value => {
					return new Promise(resolve => {//异步操作需要用promise封装才能得到异步结果
						setTimeout(() => {
							resolve('p2异步结果:'+value)
							console.log('p2------')
						}, 1000);
					})
				}, reason => {
					console.log('败: '+reason);
				})

				.then(se => {
					console.log('p3:'+se)
				},
				e => {
					console.log('p3:'+e)
				}


	promise异常穿透：
		  *当使用promise的then链式调用时，可在最后指定失败的回调，
		  	前面任何操作出了异常，都会传到最后失败的回调函数中处理

		new Promise(function(resolve,reject) {
			reject(1)
		})
		.then((val) => {
			console.log('t1 OnResolved: '+val);
			return 2
		})
		.then(value => {
			console.log('t2 OnResolved------'+value)
			return 3
		})
		.then(success => {
			console.log('t2 OnResolved------'+success)
		})
		.catch( reason => {
			console.log('reason:'+reason)
		})

		相当于:
		new Promise(function(resolve,reject) {
			reject(1)
		})
		.then((val) => {
			console.log('t1 OnResolved: '+val);
			return 2
		},
		//系统默认为每个then抛出了一个错误，相当于每一个then返回的
		//新promise状态都是rejected，直到异常穿透至catch被捕获
		reason => {throw reason} 
		)
		.then(value => {
			console.log('t2 OnResolved------'+value)
			return 3
		},
		reason => {throw reason}
		)
		.then(success => {
			console.log('t2 OnResolved------'+success)
			return 4
		},

		//报错，=>符号相当于return，而return throw会导致语法错误
		//reason => throw reason
		reason => {throw reason}
		)
		.catch( reason => {
			console.log('reason:'+reason)
		})


	中断promise链？
		*当使用promise的链式调用时，在中间中断，不在调用后面的回调函数？
		办法：在回调函数中返回一个pending状态的promise对象

		new Promise(function(resolve,reject) {
			reject(1)
		})
		.then((val) => {
			console.log('t1 OnResolved: '+val);
			return 2
		})
		.then(value => {
			console.log('t2 OnResolved------'+value)
			return 3
		})
		.catch( reason => {
			//返回新promise状态为成功值为undefined，会调用下一个then的成功回调函数
			console.log('reason:'+reason)
			//如何中断链式调用呢(不执行后续then)？
			//返回一个pending的promise,使下一个then不能调用回调函数，达到中断链式回调的目的
			return new Promise((res,rej) >= {})
		})
		.then(success => {
			console.log('t3 OnResolved------'+success)
			return 4
		}, (warn) => {
			console.log('t3 onRejected： '+warn)
		})

	
	手写(自定义)Promise:
		p20-29集：promise的定义和then已经catch的实现
		p30-33集：promise的all和race函数的实现(以上在google硬盘有自己写的实现)

		自定义promise-class版本:p35集



async和await(属于ES8版本):
	
	async函数:
		1、async函数的返回值为promise对象(相当于用promise对象将async的返回值包裹)
		2、async返回的promise对象的结果由async函数执行的返回值决定

	awiat表达式:
		1、await右侧的表达式一般为promise对象，但也可以是其他值
		2、如果await右侧表达式是promise对象，且该对象的结果是成功的，则await返回的就是promise成功的值(无需用.then获取)
		3、如果await右侧表达式是promise对象，且该对象的结果是失败的，则需要通过try...catch才能捕获到失败结果值(.then在这里无效)
		4、如果await表达式不是promise，则得到的结果就是await右侧表达式本身的值
		5、await必须写在async函数中，但async函数中可以没有await；
		
		--------------------------async----------------------------------------------

		//async函数返回的是一个promise对象；
		//promise对象的结果由async函数执行的返回值决定
		async function f1() {
			return 1
			// throw 'error'
			// return Promise.resolve('00')
			// return new Promise((resolve,reject) => {
			// 	setTimeout(() => {
			// 		resolve(7)
			// 	}, 1000);
			// })
	}

		const res = f1()

		res.then(
			value => {
				console.log('onResolved: '+value)
			},
			reason => {
				console.log('onRejected: '+reason)
			})

	  -------------------------------------------------------------------------------------

	//-------------------await------------------------------------------------------------------

		function f2() {
			return new Promise((resolve,reject) => {
				setTimeout(() => {
					// resolve(8)
					reject(10)
				}, 1000);
			})
		}

		function f4() {
			return 9
		}

		async function f3() {
			try {
				//await右侧表达式为promise，得到的结果就是promise成功的value(省去了.then的步骤，直接得到promise结果)
				//如果promise是失败的，需要用try catch才能得到失败promise结果(value.then也无法得到promise返回的结果)
				const value = await f2()
				console.log('value: ' + value)

				// const value = await f4()//await右侧表达式不是promise，得到的结果就就是表达式本身的值
				console.log('value: '+value)
			} catch (error) {
				console.log('err: '+error)
			}
		}
		f3()



宏队列和微队列:
	宏任务对象=消息队列

	1、js是单线程的，js引擎在执行代码的过程中，先执行所有同步代码，然后才执行
		队列里的回调任务，即异步任务

	2、js中用来存储待执行回调函数的队有2种类型:

		*宏队列:用来保存待执行的宏任务(回调),比如，定时器回调/DOM事件
		 回调/ajax回调等

		 *微队列:用来保存待执行的微任务回调，如:promise回调/
		 MutationObserver的回调

	3、js执行时会区别这2个队列:
		每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个
			取出来执行
	

	setTimeout(() => {//该回调函数会立即放入宏队列
		console.log('timeout callback 1')
	}, 0);

	Promise.resolve(1).then(
		val => {//该回调函数会立即放入微队列
			console.log('Promise onResolved1: '+val)
		}
	)
	//输出Promise onResolved1
	//	  timeout callback 1

	----------------------------------------------------
	//每次执行宏任务前都会检测微任务队列是否有微任务，如果有微任务，则
	//中断执行宏队列中的任务，先执行微任务，直到微任务队列是空的，才继续
	//执行宏队列任务

	setTimeout(() => {//该回调函数会立即放入宏队列 setp2
		console.log('timeout callback 1')

		Promise.resolve(3).then(
		val => {//该回调函数会立即放入微队列 setp3
			console.log('Promise onResolved3: '+val)
		}
	)
	}, 0);

	setTimeout(() => {//该回调函数会立即放入宏队列 setp4
		console.log('timeout callback 2')
	}, 0);

	Promise.resolve(2).then(
		val => {//该回调函数会立即放入微队列 setp1
			console.log('Promise onResolved2: '+val)
		}
	)

	//输出Promise onResolved2,
	//timeout callback 1,
	//Promise onResolved3,
	//timeout callback 2


	面试题:

		setTimeout(() => {//此回调函数输入宏队列
			console.log(1)
		}, 0);

		new Promise((resolve,reject) => {//执行器函数是同步代码
			console.log(2)
			resolve()
		})
		.then(//then是同步代码
			val => {//此回调函数输入微队列
				console.log(3)
			}
		)
		.then(
			val => {
				console.log(4)
			}
		)
		console.log(5)
		//输出2,5,3,4,1

		重点:
			1、执行器函数是同步代码；

			2、在输出3之前，4所在的回调函数还不在微队列中，
			   因为要等3的回调执行后返回的结果(失败/成功)，来确定4这个
			   成功回调的执行，如果3返回成功，4所在的回调函数才会被加入
			   微队列中并执行


	面试题:	
		https://www.bilibili.com/video/BV1WE411P7e6?p=40&spm_id_from=pageDriver



----------
继续接本文件的1907行 ES6课程
https://www.bilibili.com/video/BV1uK411H7on?p=33&spm_id_from=pageDriver

ES6 Class(类):
	ES6引入了class的概念，通过class关键字来定义类(对象模板),ES6的class可
	看作为一个语法糖，他的绝大部分功能ES5都可以做的；ES6的class写法只是让
	对象原型的写法更加清晰，更像面向对象编程的语法而已。


	
	ES5的方式:用构造函数实例化一个对象

		// 类的构造函数
		function Phone(brand,price) {
			this.brand = brand
			this.price = price
		}

		Phone.prototype.call = function() {
			console.log('我可以打电话')
		}

		// 实例化对象
		let mi = new Phone('小米',3500)
		mi.call()
		console.log(mi)



	ES6的方式:
		class Mobile {
			//类的构造方法，名字不能修改
			constructor(brand,price) {
				this.brand = brand
				this.price = price
			}
			//方法必须使用该语法，不能使用ES5的对象完整形式
			call() {//此方法直接定义在了Mobile对象的原型中
				console.log('我可以打电话')
			}

			// 不能使用ES5的对象完整形式
		// 	cool: function () {	
		// 	}
		}
		let onePlus = new Mobile('1+',5000)
		onePlus.call()
		console.log(onePlus)


ES6类的静态成员(对应ES5的函数对象):

	*ES5的函数对象实际上就是ES6的类的静态属性

	ES5的函数对象:

		function Phone() {
					
		}
		//以下2个属性属于函数对象，不属于实例对象
		//即函数对象(ES5的叫法)等于静态成员；
		//用面向对象的思想去描述:他们是属于类的，而不是属于实例对象
		Phone.name = '手机'
		Phone.change = function () {
			console.log('改变一切')
		}
		let p = new Phone()
		console.log(p.name)//undefined
		Phone.change()//手机


	ES6的类的静态成员:
		class Phone {
			constructor() {

			}
			//类的静态属性
			static name = '手机'
			static change() {
				console.log('改变')
			}
		}

		let nokia = new Phone()
		console.log(nokia.name)//undefined
		console.log(Phone.name)//手机



	后续的ES6没有做笔记了(该视频ES6系列已经全部看完)
	ES7-ES11没有什么重要的特性，没看


	-------------JS高级和ES6 END----------------------------



------------------------------------------js 核心-----------------------------------------------
https://www.bilibili.com/video/BV1xh411S7nN?from=search&seid=2343167973044378660&spm_id_from=333.337.0.0


正则表达式Regular Expression:
https://www.bilibili.com/video/BV1xb411679x?from=search&seid=2431262280937555521&spm_id_from=333.337.0.0
	js风格的正则写法(用的比较少):
		let re = new RegExp('a') //插找指定字符
		let str = 'acdefg'//被查找目标

		console.log(str.search(re))//返回字符(区分大小写)下标，不存在返回-1

	perl风格:
		var re = /a/  //查找指定字符，两个/符号中的内容就是正则表达式
		let str = 'acdefg'//被查找目标
		console.log(str.search(re))//返回字符下标，不存在返回-1

	search函数返回匹配字符的位置下标

	-------------------------------------------------------------
	忽略大小写:
		let re = new RegExp('a','i') //i igonre代表忽略大小写，插找指定字符
		let str = 'acdefg'//被查找目标

		console.log(str.search(re))//返回字符

	----------------------------------------------
	转义符:\d  代表数字，一个\d代表一位数字
		let str = 'Acdefg 432 23 valdsa'//被查找目标

		let re =/\d/

		alert(str.search(re))


	match函数:
		把匹配的值，显示出来，配合参数g可以将匹配到的数据全部提取出来
			let str = 'Acdefg 432 23 vald89'//被查找目标

			let re =/\d/g //g global 找到目标所有的数字(如果没有g，match函数只会匹配一个)

			alert(str.match(re))


		匹配指定位数的数字
			let str = 'Acdefg 432 23 vald89'

			let re =/\d\d\d/g //全局只匹配三位数字，

			alert(str.mch(re))

		匹配指定位数的数字
			let str = 'Acdefg 432 23 vald89'

			let re =/\d+/g //匹配若干个数字

			alert(str.mch(re))

	
	replace函数:
		let str = 'acdefg 43aaa2 23 vaald89'

		let re =/a/g // 匹配全局字符a

		alert(str.replace(re,'*')) //将匹配的值换成*


	test函数:
		检查字符串是否符合正则的规则，(实际上)只要部分符合就会返回true


	正则中的方括号[](在正则中方括号叫元字符) :
		let str = 'ac3defd2g ac13aaa2 ac23 vaaldac89'

		let re =/[ach]\d/g // [匹配到a或c或h开头的数字]
							// [a-z]方括号还能匹配范围
							//[^a-z]排除字母
							//[a-z0-9A-Z]还可以配合使用

		alert(str.match(re)) 



	常用的转义字符:
		. ：代表任意一个字符
		\d 数字0-9
		\w 英文，数字，下划线 a-z0-9_
		\s 空白字符

		\D 非数字
		\W 非英文，数字，下划线 a-z0-9_
		\S 非空白字符


	贪婪模式:
		正则表达具备一个特性(默认的):贪婪，
		即它会去匹配尽可能长的字段，越长越多越好。


	量词(数量词):
		{n} 正好出现n次(或者理解为匹配数字的位数)
			如匹配手机号码: /[1-9]\d{10}/  //\d{10} = \d*10(即10个\d)

		{n,m} 最少n次(位数字)，最多m次(位数字)
			匹配qq号: /[1-9]\d{4,10}/

		{n,} 最少n位数字，最多不限

		? 在正则中相当于 {0,1}
			匹配固定电话: 
			(0\d{2,3}-)?[1-9]\d{7} //区号可有可无，所以使用?号

		* 相当于 {0,}  可匹配空，也可匹配任意位

	其他:

		^ 等于排除,如[^a-z] 排除字母；
		^ 也代表了行首(字符串开头)的意思

		$ 匹配行尾(字符串结尾)

		例子:
			/^\w+@[a-zA-Z0-9]\.[a-z]+$/i

			在^和$中间只能出现正则匹配的内容，相当于前后两扇门




严格模式:
	ES5版本中推出的机制

	推出原因:因为js这门语言，有很多广受诟病的缺陷

	什么时候用: 一般生成环境下的js程序都要运行在该模式下

	怎么用: 在代码的顶部，写上"use strice"; 双引号和分号都是必须的

	严格模式下的一些限制和好处:
		1 禁止给未声明的变量赋值

		2 严格模式下，静默失败会升级为错误:
			静默失败:执行不成功，也不报错(不便于调试)

		3 普通函数调用和匿名函数自调用中的this不再默认指向window，而是
			指向undefined，防止内存泄漏和全局污染

		4 禁止使用arguments.callee
			啥是arguments.callee: 是在函数运行时，专门获得当前正在执行的
				函数名(一般在递归的情况下)
				；arguments.callee=当前在执行的函数名










-----------------------js 网络相关--------------------------

axios:

fetch:




-----------------------js 网络相关END--------------------------








	











	





	






	



	










20200717:

在webStorm调试react项目
1.安装jetbrains ide suppor插件(chrome)
2.项目启动后，在页面右击inspect in webstorm后，将连接idea
3.对需要调试的代码打断点
4.触发需要调试的页面，开始调试

调用栈，任务队列，宏任务，微任务，事件循环 关乎代码的执行任务？

--------------------------

--------------------------


--------------------------
 
--------------------------

函数和方法的区别：
函数(如test())是一段代码，需要通过名字来进行调用；
方法(如:p.test())（method）是通过对象调用的javascript函数。也就是说，方法也是函数，只是比较特殊的函数。 

在方法中，this引用(代表)所有者对象，
单独使用，this引用(代表)全局对象，
在函数中，this引用(代表)全局对象，
在事件中，this引用(代表)接收事件的的元素


--------------------------

javascript：
	DOM是浏览器提供的，document，history，navigation...都是浏览器提供的对象，不是js提供的.

	编码者编写的代码就像是'插销'的插，浏览器(js引擎)提供的API就像是'销'(js是寄生于浏览器的同时js需要宿主提供API，js不能独立运行)，
	负责解析js脚本(显示对象、字符的长度、改变div的颜色等，这些事情都是浏览器去做的，
	js不能进行网络操作、IO读写、数据库连接等，因为这些操作都是要通过操作系统才能完成的，因此js只能算是脚本不能叫编程语言；
	当js不在浏览器中运行，放在操作系统中运行时这就是nodeJS(等于是把v8引擎放在了操作系统))


Node JS：
	js代码在Node出现之前是运行在浏览器上的(即浏览器环境)，Node JS就是将chrome浏览器的V8引擎
	从浏览器摘出来，放在操作系中(操作系统环境)，以达到控制操作系统的API(事件驱动，异步非阻塞IO，单线程)的目的；
	Node不是独立的语言，不是JS框架；Node是一个运行环境，是一个除浏览器外的，可以让js代码运行的环境。

	现在js运行的环境(宿主)变成了操作系统,宿主就可以给js提供自身的API(比如读写文件的操作)；当js的宿主是浏览器时，宿主就可以提供history，navigation等浏览器对象给js调用；

	比如:XmlHttpRequest对象是就是浏览器提供的API，js用它操作浏览器发起网络请求；

	Node可以这样理解:除了浏览器环境，其他环境(一般都是操作系统)
	要想跑js代码，就必须要有Node环境.

	操作系统环境会给js提供三大类模块:
	核心模块(node自带)，第三方模块(需要install)，自定义模块(自己写)

	如果安装了多个版本的Node，可以使用nvm工具进行管理。
	在进行RN开发时，其实使用的就是Node环境(部署到手机也会吧node一同打包)

	REPL环境:
		chrome浏览器的控制台可以直接输入代码并运行(但不能运行写到文件中代码)；
		双击Nodejs.exe打开的窗口；
		在开发工具中的terminal键入node后的页面；
		都叫REPL环境

	file System：
		ReactNative使用React-native-fs
		方括号[]中的参考代表可选参数
		fs.readFile(path[, options], callback)

	import和require的区别:
		调用时间：
		require是运行时调用，所以require理论上可以运用在代码的任何地方
		
		import是编译时调用，所以必须放在文件开头

		本质:
		require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量

		import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require

	异步:
		以ajax为例，代码执行顺序是一直往下执行，当碰到异步的代码被服务器回写的数据触发响应时，异步代码被执行；
		同步是代码按顺序执行，上面的代码没执行完下面的代码得等着，异步则可以前面的代码没执行完(如ajax发送请求等待服务器处理并响应
		数据的代码)后面的代码将不等待异步代码的执行完毕，继续执行下面
		的代码，异步代码什么时候被调用则什么时候插队执行(如服务器响
		应数据完毕后，执行打印服务器返回数据的异步代码)
		详见:https://www.bilibili.com/video/BV1TJ411d7cV?p=10

	在node中的回调函数都是异步。

	w3c是浏览器的js规范，commonJS是除浏览器以外的js规范，如后台nodejs。

	commonJS的模块规范:
		1 模块引入:使用require()方法引入一个模块API
		2 模块定义
		3 模块标识
--------------------------



	js内一切都可以视为对象。
	js可以嵌套到html中，是基于对象和事件驱动的脚本语言(无需编译,解释性语言；可嵌入到其他语言)

	特点：
		1、加互性
		2、安全性：js不能访问本地磁盘
		3、跨平台：浏览器中都具备js解析器

	用处：
		1、js能动态修改（增删）html和css的代码
		2、能动态校验数据

	引入js的方式：
		1、内嵌脚本： type="button" name="button" value="按钮" onclick="alert('内嵌脚本')">

		2、内部脚本（页面加载完后执行）:
				<head>
					<script type="text/javascript">
						alert('内部脚本');
					</script>
				</head>

		3、创建一个js文件
			在引入到html中<script type="text/javascript" src="jsdemo1.js"></script>

		##js代码放在哪个标签（位置适当可以起到优化网站的作用）？
		   放在哪都行<hean>、<body>..，但是在不影响html功能的前提下，越晚加载越好##

	js语法
		变量：
			（1）
			var x =7;（不写分号也能运行）

			x='javascript';（单引和双引是一样的，都是字符串）

			##在java中，变量名即等于在内存中开辟了一块空间用于存放对应类型的数据。java变量定义为强类型；
			而js的变量只是一块内存区域，变量类型根据值的类型而变化。js变量定义为弱类型##

			var y ="hello";

			var b =true;

			*第三集
		原始数据类型：
			（1）number 数字类型
			（2）string 字符串类型
			（3）boolean 布尔类型
			（4）null 空类型（object类型）
				出现null的条件，
				对象不存在就是null
			（5）undefined 
				出现undefined的前提，
				变量声明且没有赋值；获取对象中不存在的属性；函数有形参但没有传实参时形参的值是undefined；函数没有return或return后面没有任何东西，调用函数后得到的值是undefined
			 (6) object(对象类型包含了数组，方法，function)

			lert(typeof(x)); 获取变量x所属的类型

			类型转换：
				number\boolean\string是伪对象

				number\booblean转string：
					toString();

				string\boolean转number：
					parseInt();
					parseFloat();
					boolean用以上方法不能转
					string可以将数字字符串转换成number，如"123aa3e66"=123

			强制转换：
				Boolean(value); 强转成布尔，
				数字强转成不布尔，非0就是true，反之就是false
				字符强转成不布尔，非""就是true，空字符串""就是false

				Number(value); 强转成数字
				布尔转数字 true转成1 false=0；字符串转数字不能强转

		引用数据类型：
			java：Object obj = new Object();

			js: var obj = new Object();




		自增和自减:

			let a = 1
			// console.log('a = '+ a++) //a++的值等于原变量的值(自增前的值)
			console.log('a = '+ ++a) //++a的值等于加1后的新值

			console.log('a = '+a) 

			//以上规则同样适用于自减
			10，11，12，12，20，19，18，18


		运算符：
			（1）赋值运算符
				var x=5;

			（2）算数运算符
				+ - * / % 
					+ 遇到(数字)字符串变成连接(得到的是拼接后的数字)
					- 遇到(数字)字符串先把字符串转成数字然后进行运算
					* 先把字符串转成数字然后进行运算
					/ 先把字符串转成数字然后进行运算

			（3）逻辑运算符
				&&  ||

			（4）比较运算符
				<  >  =  <=  >=  ==  !=  
				===:全等，类型与值都要相等

				*任何值和NaN作任何比较都是false

				*如果运算符两边比较的是字符串，实际上是在比较字符串的Unicode	码

			（5）三元运算符
				和jave相同: 3>2 ? "真":"假";

			（6）void运算符
				<a href="javascript:void(0);">xxxx</a>
				如果在此设置一个錨,点击后将不会跳转

			（7）类型运算符
				typeof：判断数据类型，返回当前数据的类型
					语法:var n = 1;
						alert(typeof obj);

				instanceof：判断数据类型，是否属于某种类型/对象
					语法：var t = new Boolean();
						alert(t instanceof Boolean);

		逻辑语句：
			（1）if-else
			（2）for
			（3）switch
			（4）wiherl
			（5）for in
				var arr = [1,3,5,6,"jas"];
				for(index in arr){//index代表下标 
				// alert(index);//输出元素的下标
				alert(arr[index]);//输出数组中的内容
				}


		循环:
			break:
				break关键字可以用来退出循环或switch语句
				break会立即终止离他最近的那个循环语句

			continue：
				continue关键字可用来跳过当此循环

			注意:不能在if语句中使用break和continue关键字

			---------------------------------------------
			while循环:
				语法:
					while(条件表达式) {//条件为真才会执行循环体
						循环体
					}

			do...while循环:
				语法:
					do{//最少会执行一次循环体
						循环体
					}while(条件表达式)


			---------------------------------------------

			简单for循环:

			for in循环

			forEach循环：

				*IE8及以下浏览器不支持此方法
				*forEach不能break和return
				*只能遍历数组
				*不会改变原数组
				注意： forEach对于空数组是不会调用回调函数的


				需要传入一个回调函数作为参数；
				浏览器会在回调函数中传递3个函数:
					第一个参数，就是正在遍历的元素
						二参数，元素的索引
						三参数，就是正在遍历的数组

				arr.forEach(function(a,b,c) {

				})
				

			map循环:
				只能遍历数组;
				不会改变原数组;
				map方法返回一个新的数组;
				map方法不会对空数组进行检测;
				传入的参数和froEach一样:分别为item（当前每一项），
				index（索引值），arr（原数组）



			for of循环:





		包装类:
			在js中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型
			转换为对象:

				String()
					可以将基本数据类型字符串转换为String对象
				Number()
					可以将基本数据类型数字转换为Number对象
				Boolean()
					可以将基本数据类型布尔值转换为Boolean对象

				//将基本类型包装成对象
				let num = Number(3)
				let str = String('hello')
				...

				*但是注意，我们在实际开发中不会使用基本数据类型对象，
					如果使用基本数据类型对象，在做一些比较时可能会带来
					一些不可预期的结果




		对象字面量:
			语法:
				let obj = {}

			使用对象字面量，可以在创建对象时，直接指定对象中的属性

	js内置对象
		（1）Number
		（2）Boolean
		（3）Stirng
		（4）Array
		（5）Date
		（6）Math
		（7）RegExp

	js的函数

	js的事件

	js的bom

	js的dom



	export 和 export default 的区别:
	https://www.jianshu.com/p/edaf43e9384f
	1.export与export default均可用于导出常量、函数、文件、模块等
	2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用
	3.在一个文件或模块中，export、import可以有多个，export default仅有一个
	4.通过export方式导出，在导入时要加{ }，export default则不需要

	export导出指定的变量、函数、对象；在用import导入该变量时，必须使用大括号包
	裹而且要和export导出时的名字一致

	export default命令对外输出的变量名可以是任意的，这时import命令后面，不使用大括号。
	export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令




























Servlet：
 URL(统一资源定位符，即网址):http://localhost:8008/src/cc1.html
 URI(统一资源标志符):即网址所访问的资源(当前应用的资源) ，端口后面即URI:src/cc1.html


 Tomcat
 	tomcat从6.0以后支持集群

 	tomcat的主要目录:
 		bin 可执行文件
 		conf 配置文件
 		lib tomcat运行时需要用到的jar文件
 		logs tomcat运行时产生的日志文件
 		temp 运行时产生的临时文件
 		webapps 存放自己编写的应用
 			默认就有5个应用
 		work tomcat的工作目录

 	标准javeweb应用结构目录(MyEclipse):
 		--ProjectName
 			--src
 				package
 					java类
 			--WebRoot
 				--1.html
 				--css
 					myStyle.css
 				--js
 					my.js
 				META-INF:Myeclipse的配置信息(不用管)
 				WEB-INF:(此目录下的文件不能被外部直接访问)
 					classes:我们编写的编译后的程序代码.class文件(即项目src中的编译后的.class)
 					lib:应用需要的jar文件
 					web.xml:应用的配置信息

 			部署即是将webapp或WebRoot下的文件夹和文件部署到tomcat中的webapps(该目录中需命名一个最好和项目相同的文件夹)中(将webroot中2的文件夹和文件
 			复制到tomcat的webapps目录中再启动服务器是为手动部署)



 	虚拟目录:(虚拟目录的作用是让应用放在其他盘符也能被tomcat管理)
 		方式一:(不建议使用,因为需要重启服务器)
 		真实目录:d:\MyApp
 		虚拟目录:http://localhost:8080/MyApp

 		虚拟目录映射:
 			在tomcat配置文件中找到以下代码
 			<Context path="myApp" docBase="d:\MyApp"/>
 			docBase:代表的是应用的真实路径.
 			path:网络访问的虚拟目录名(即通过该虚拟目录找到真实的访问路径)

 		方式二:(不用重启服务器)
 			新建myApp.xml文件,文件名(可自定义)就代表应用的虚拟目录名
 			将文件放在tomcat目录的conf>Catalina>localhost目录下
 			文件内容:
 				<?xml version="1.0" encoding="utf-8"??
 				<Context docBase="D:\myApp"/>

 	配置默认端口、默认应用、默认主页

 		默认端口:把serve.xml中<Connector port="80" protocol="HTTP/1.1"
 							   connectionTimeout="20000" redirectPort="8443"/>
 							   浏览器默认端口为80,在输入访问路径时可以不输入端口号

 		默认应用:(平时访问的所谓tomcat首页即使一种默认应用)
 			把配置的虚拟目录的配置名文件改为ROOT.xml即可.



 		默认主页即:web.xml中的<welcome-file-list>
 							<welcome-file>1.jsp</welcome-file>
 						<welcome-file-list>

 	web.xml
 		在web-app元素内，元素的配置顺序与工程的加载顺序无关，web.xml的加载过程为：

			1 启动一个web项目，web容器（如tomcat）读取web.xml文件，读取其中的配置信息

			2 容器创建一个servlet上下文（servletContext），这个web项目所有部分共享这个上下文

			3容器将<context-param>转换为键值对，交给servletContext

			4容器创建<listener>中的监听器实例

			5触发contextInitialized方法，listener被调用（当Servlet 容器启动或终止Web 应用时，
			会触发ServletContextEvent 事件，该事件由ServletContextListener 来处理。在
			ServletContextListener 接口中定义了处理ServletContextEvent 事件的两个方法contextInitialized；contextDestroyed，web.xml有contextLoaderListener监听器，
			spring等框架实现了本监听器的接口方法）

			6调用完contextInitialized方法后，容器再对filter初始化

			7容器对web.xml中的指定load-on-startup的值为正数Servlet初始化（优先级1,2,3...->递减），负数或不指定则在该Servlet调用时初始化(springMVC的初始化为此阶段

			结论：web.xml 的加载顺序：
				ServletContext -> context-param（无顺序）-> listener（无顺序）-> filter（书写顺序） -> servlet（load-on-startup优先级）

			web.xml文件中配置<context-param>和<init-param>的区别
				<context-param>和<init-param>都是上下文参数，但它们的范围和使用方式不同。

				<context-param>是application范围内的初始化参数，用于向servlet-context提供键值对，即应用程序的上下文信息，listener、filter等初始化时会用到这些信息

				<init-param>是servlet范围内的参数，只能在servlet类的init()方法中取得

	
	form标签
	属性:name：表单名称
		 action：提交的路径地址
		 method：提交方式get（默认使用get方式）；post
		 	get和post的区别：
		 		1、get提交将数据加在地址栏后面，格式?name=value?password=value?....而post是将数据封装在
		 		   请求体中（其在请求体中的展示形式和get的差不多）

		 		2、get提交比较不安全，post提交相对安全

		 		3、get提交有大小限制，根据浏览器不同而不同；post不限制大小

